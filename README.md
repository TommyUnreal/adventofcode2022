### Advent of Code 2022
This repository contains solution of https://adventofcode.com/2022.

Puzzles in folders with **`_by_ai`** suffix were solved using [Large Language Model](https://techcrunch.com/2022/04/28/the-emerging-types-of-language-models-and-why-they-matter/) [bloom](https://huggingface.co/bigscience/bloom). **This means that a working code was generated by another code, not human by programmer!** I just transformed Puzzle to simpler form. The input for LLM is documented in every generated py-file.

### Thanks
Great thanks goes to to [Eric Wastl](https://twitter.com/ericwastl) for Puzzles!

### Highlights & Lesson learned
#### Day 1
**`HIHGLIGHT`** Searching max 3 translates to $O(3n)$, sorting the list to $O(n \log n)$. And I like it.

**`LESSON`** I have entered AoC via google autentification. Keep that in mind. ðŸ¤£

#### Day 2
**`HIHGLIGHT`** Fancy terminal output be like:
```
ðŸ§ plays âœŒï¸, ðŸ‘± play âœŒï¸! Game score is 6.
ðŸ§ plays âœ‹, ðŸ‘± play âœ‹! Game score is 5.
ðŸ§ plays âœŠ, ðŸ‘± play âœ‹! Game score is 8.
ðŸ§ plays âœŠ, ðŸ‘± play âœŠ! Game score is 4.
ðŸ§ plays âœ‹, ðŸ‘± play âœ‹! Game score is 5.
```

**`LESSON`** To override sum function, use
```python
    def __radd__(self, other):
        return other + self.score
```

#### Day 3
**`HIHGLIGHT`** With the second day in three days dealing with an inventory of elves, we are heading into RPG territory.
```python
class Elf():
    """Class for keeping track of elf and it's in inventory."""
```

**`LESSON`** To group content of a list (or other iterable) using itertools:
```python
def group_list(n, iterable:list) -> list:
    """Group iterable to list of tuples of size n."""
    args = [iter(iterable)] * n
    return list(zip_longest(*args))
```

**`LESSON`** To find intersection of multiple lists very fast:
```python
def find_intersection(list_of_lists:list) -> list:
    """Find the intersection of all lists in list_of_lists."""
    return list(set.intersection(*[set(list) for list in list_of_lists]))
```

#### Day 4
**`HIHGLIGHT`** Writing (as much as I can) maintainable code takes me about 3x more time. Usually, it pays back a little in the second puzzle. This time adding one extra method did it. And I used the lesson from yesterday, yay!
```python
def sections_intersect(self) -> bool:
    """Compute if range of sections in pair responsibility intersect the other.

    Returns:
        bool: True if ranges intersect, False otherwise.
    """
    return bool(find_intersection([
        range(self.elf_1_sections[0], self.elf_1_sections[1]+1), 
        range(self.elf_2_sections[0], self.elf_2_sections[1]+1)
        ]))
```

**`LESSON`** *Readability counts.* This is the 7th line of [Zen of Python](https://peps.python.org/pep-0020/). The older I'm the more I understand this ðŸ¤£. That's why I decided to document the code well this year.
```python
def __init__(self, pair: str) -> None:
    """Transform line output and save to elf_1_sections elf_2_sections attributes.

    Section interval in "pair" input are separated with "-", elves with ",".
    
    Args:
        pair (str): Input line in format "2-4,6-8".
    """
    pair = pair.split(",")
    self.elf_1_sections = [int(section) for section in pair[0].split("-")]
    self.elf_2_sections = [int(section) for section in pair[1].split("-")]
```
